syntax = "proto2";

package st.planning;
// option go_package = "st.proto.ai/onboard/planning.decision/proto/constraint";

import "modules/cnoa_pnc/planning/proto/halfplane.proto";
import "modules/cnoa_pnc/planning/proto/affine_transformation.proto";
import "modules/cnoa_pnc/planning/proto/crosswalk_state.proto";
import "modules/cnoa_pnc/planning/proto/piecewise_linear_function.proto";
import "modules/cnoa_pnc/planning/proto/prediction_common.proto";

message SourceProto {
  message TrafficLight {
    optional uint64 id = 1;
    optional uint64 lane_id = 2;
  }
  message Crosswalk {
    optional string crosswalk_id = 1;
    repeated string object_id = 2;
  }
  message NoBlock {
    optional string id = 1;
  }
  message SpeedBump {
    optional string id = 1;
  }
  message EndOfPathBoundary {
    optional string id = 1;
  }
  message TrafficStaticObstacles {
    optional string id = 1;
  }
  message Intersection {
    optional string id = 1;
  }
  message CloseObject {
    optional string id = 1;
  }
  message EndOfCurrentLanePath {
    optional string id = 1;
  }
  message RouteDestination {
    optional string id = 1;
  }
  message LcEndOfCurrentLane {
    optional string id = 1;
  }
  message ParkingBrakeRelease {
    optional string id = 1;
  }
  message BlockingStaticObject {
    optional string id = 1;
  }
  message Pedestrian {
    optional string id = 1;
  }
  message Toll {
    optional string id = 1;
  }
  // Note: Standby just used for visualization currently, if used as
  // decision in the future, delete this comment.
  message Standby {
    optional string reason = 1;
  }
  message Standstill {
    optional string reason = 1;
  }
  message PullOver {
    optional string reason = 1;
  }
  message BrakeToStop {
    optional string reason = 1;
  }
  // Freespace planning.constraint.
  message EndOfLocalPath {
    optional string reason = 1;
  }
  message BeyondLengthAlongRoute {
    optional string id = 1;
  }
  message SolidLineWithinBoundary {
    optional string id = 1;
  }
  message OccludedObject {
    optional string id = 1;
  }
  message DenseTrafficFlow {
    optional string id = 1;
  }
  message StopPolyline {
    optional string id = 1;
  }
  message LaneMerge {
    optional string reason = 1;
  }
  message ConstructionScene{
    optional string reason = 1;
  }
  oneof type {
    TrafficLight traffic_light = 1;
    Crosswalk crosswalk = 2;
    NoBlock no_block = 3;
    SpeedBump speed_bump = 4;
    EndOfPathBoundary end_of_path_boundary = 5;
    Intersection intersection = 6;
    CloseObject close_object = 7;
    EndOfCurrentLanePath end_of_current_lane_path = 8;
    RouteDestination route_destination = 25;
    LcEndOfCurrentLane lc_end_of_current_lane = 9;
    ParkingBrakeRelease parking_brake_release = 10;
    BlockingStaticObject blocking_static_object = 11;
    Pedestrian pedestrian_object = 12;
    Standby standby = 13;
    Toll toll = 14;
    Standstill standstill = 16;
    PullOver pull_over = 17;
    EndOfLocalPath end_of_local_path = 18;
    BeyondLengthAlongRoute beyond_length_along_route = 19;
    BrakeToStop brake_to_stop = 20;
    SolidLineWithinBoundary solid_line_within_boundary = 22;
    OccludedObject occluded_object = 23;
    DenseTrafficFlow dense_traffic_flow = 24;
    StopPolyline stop_polyline = 26;
    TrafficStaticObstacles traffic_static_obstacles = 27;
    LaneMerge lane_merge = 28;
    ConstructionScene construction_scene = 29;

    // Next id: 30.
  };
  reserved 15, 21;
}

message ConstraintProto {
  message AvoidLineProto {
    repeated Vec2dProto xy_points = 1;
    message SLPoint {
      optional double s = 1;
      optional double l = 2;
    }
    repeated SLPoint sl_points = 2;
    optional SourceProto source = 3;
    optional string id = 4;
  }

  message StopLineProto {
    optional HalfPlaneProto half_plane = 1;
    // Accumulated s on drive passage.
    optional double s = 2;
    // Expect AV to keep a distance from stop line.
    optional double standoff = 3;
    // Time remaining to active stop line.
    optional double time = 4;
    // Id of constraint.
    optional string id = 5;
    // Constraint source.
    optional SourceProto source = 6;
    optional bool is_extended = 7;
    optional bool is_traffic_light = 8;
  }

  message SpeedRegionProto {
    optional Vec2dProto start_point = 1;
    optional Vec2dProto end_point = 2;
    // Accumulated s on drive passage.
    optional double start_s = 3;
    // Accumulated s on drive passage.
    optional double end_s = 4;
    optional double max_speed = 5;
    optional double min_speed = 6;
    optional string id = 7;
    optional SourceProto source = 8;
  }

  message PathStopLineProto {
    optional HalfPlaneProto half_plane = 1;
    // Accumulated s on path for rac point.
    optional double s = 2;
    // Expect AV to keep a distance from stop line.
    optional double standoff = 3;
    // Time remaining to active stop line.
    optional double time = 4;
    // Id of constraint.
    optional string id = 5;
    // Constraint source.
    optional SourceProto source = 6;
  }

  message PathSpeedRegionProto {
    optional Vec2dProto start_point = 1;
    optional Vec2dProto end_point = 2;
    // Accumulated s on path.
    optional double start_s = 3;
    // Accumulated s on path.
    optional double end_s = 4;
    optional double max_speed = 5;
    optional double min_speed = 6;
    optional string id = 7;
    optional SourceProto source = 8;
  }

  message LeadingObjectProto {
    enum Reason {
      BORROW_BOUNDARY = 1;
      LANE_CHANGE_TARGET = 2;
      BLOCKING_STATIC = 3;
      TRAFFIC_WAITING = 4;
      INTERSECTION = 5;
      UNABLE_TO_OVERTAKE = 6;
      AFTER_STOPLINE = 7;
    }
    optional string traj_id = 1;
    optional Reason reason = 2;
    optional bool is_group_tail = 5;
    message STConstraint {
      optional double t = 1;
      optional double s = 2;
    }
    repeated STConstraint st_constraints = 3;
    repeated PredictedTrajectoryPointProto modified_trajectory = 4;
  }

  message SpeedProfileProto {
    optional SourceProto source = 1;
    optional PiecewiseLinearFunctionDoubleProto vt_upper_constraint = 2;
  }

  message TrafficGapProto {
    optional string leader_id = 1;
    optional string follower_id = 2;
    message GapPointProto {
      optional double gap_len = 1;
      optional double ttc = 2;
      optional double v = 3;
      optional double a = 4;
      optional double t = 5;
      optional double total_cost = 6;
    }
    optional GapPointProto gap_point = 3;
    optional bool is_gap_cal = 4;
    optional bool follow_traffic_flow = 5;
    message BestGapCountProto {
      optional string lead_id = 1;
      optional string follow_id = 2;
      optional uint64 gap_count = 3;
    }
    repeated BestGapCountProto best_gap_count = 6;
    optional double traffic_flow_v = 7;
  }

  repeated StopLineProto stop_line = 1;
  repeated SpeedRegionProto speed_region = 2;
  repeated PathStopLineProto path_stop_line = 5;
  repeated PathSpeedRegionProto path_speed_region = 6;
  repeated AvoidLineProto avoid_line = 7;
  repeated SpeedProfileProto speed_profile = 8;

  optional TrafficGapProto traffic_gap = 9;

  reserved 3, 4;
  // Next id: 9.
}

message FsdTrafficLightDeciderStateProto {
  optional sfixed64 last_light_status = 1;
  optional sfixed64 valid_light_status = 2;
  optional sfixed64 light_stop_reason = 3;
  optional double dist_to_junction = 4;
  optional double green_to_yellow_time = 5;
  optional bool green_to_yellow = 6;
  optional bool pass_junction = 7;
  optional bool set_leftwait = 8;
  optional sfixed64 light_counter = 9;
  optional double change_to_unknown_time = 10;
  optional bool unknown_check = 11;
  optional bool fail_detect_enter_leftwait = 12;

  message FsdMultiTrafficLightDeciderStateProto {
    optional sfixed64 last_light_status = 1;
    optional sfixed64 current_light_status = 2;
    optional sfixed64 light_stop_reason = 3;
    optional double green_to_yellow_time = 4;
    optional bool green_to_yellow = 5;
    optional double stop_s = 6;
  }

  repeated FsdMultiTrafficLightDeciderStateProto multi_junc_tl_info = 13;
  optional sfixed64 tl_stop_interface = 14;
  optional bool override_passable = 15;
  optional int32 override_count = 16 [default = 0];
  optional int32 block_light_count = 17 [default = 0];
  optional int32 none_count = 18 [default = 0];
  optional bool normal_override_passable = 19;
  optional double first_yellow_time = 20;
  optional double yellow_keep_time = 21;
}

message TrafficLightDeciderStateProto {
  optional bool last_tl_proceed = 1;
  optional bool entry_with_left_light_not_red = 2;
  optional bool has_received_known_traffic_light = 3;
  optional string last_tl_decision_lane_id = 4;
  optional FsdTrafficLightDeciderStateProto fsd_tld_state = 5;
}

message StopPolylineDeciderStateProto {
  optional Vec2dProto passable_stop_point = 1;
}

message TrafficGapTimeProto {
  optional bool cool_down = 1 [default = false];
  optional bool gap_cal_start = 2 [default = true];  // start gap cal, for start time
  optional double gap_cal_start_time = 3;
  optional double gap_cal_cd_time = 4;  // cool down time
}

message DeciderStateProto {
  optional TrafficLightDeciderStateProto traffic_light_decider_state = 1;
  repeated st.planning.CrosswalkStateProto crosswalk_state = 3;
  optional StopPolylineDeciderStateProto stop_polyline_state = 4;
  optional TrafficGapTimeProto traffic_gap_time = 5;
  optional ConstraintProto.TrafficGapProto traffic_gap = 6;
  repeated ConstraintProto.TrafficGapProto candidate_traffic_gap = 7;
  reserved 2;
}
