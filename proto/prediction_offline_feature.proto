

syntax = "proto2";

package fsd.prediction.prediction_offline_feature;

message Vec2d {
  optional double x = 1 [default = 0.0];
  optional double y = 2 [default = 0.0];
}

message Tensor {
  optional string name = 1;
  repeated float value = 2;
  repeated int32 shape = 3;
}

message PolylineInfo {
  enum PolylineType {
    UNSET = 0;
    Obstacle = 1;
    Lane = 2;
    LaneBoundary = 3;
    RoadBoundary = 4;
    Polygon = 5;
    Stopline = 6;
    Occulusion = 7;
  }
  optional string polyline_id = 1;
  optional PolylineType type = 2;
}

message VecPoint {
  repeated Vec2d points = 1;
  optional PolylineInfo.PolylineType polyline_type = 2;
}

message LaneVector {
  optional VecPoint vec = 1;
  optional float heading = 2;    // map coordinate
  optional bool is_virtual = 5;  //
  optional int32 lane_type = 7;  //
  optional int32 light_status = 6;
  optional double speed_limit = 8;
  optional int32 stop_line = 9;   // default lane end point
  optional int32 turn_type = 10;  // only add in junction lane
}

// for LaneBoundaryVector type
//  UNKNOWN = 0,
//  LANELINE = 1,
//  CURB = 2,
//  CENTER = 3,
//  GUARDRAIL = 4,
//  CONCRETE_BARRIER = 5,
//  FENCE = 6,
//  WALL = 7,
//  CANOPY = 8

message LaneBoundaryVector {
  optional VecPoint vec = 1;
  optional int32 type = 2;
  optional float heading = 3;
}

message PolygonVector {
  optional VecPoint vec = 1;
  optional int32 type = 2;
}

message ObstacleVector {
  optional int64 seq_num = 1;
  optional double timestamp = 2;
  optional VecPoint vec = 3;
  optional Vec2d velocity = 4;
  optional Vec2d acc = 5;          // not dump
  optional float dist_to_adc = 6;  // distance to autonomous driving car
  optional float heading = 7;
  optional float length = 8;
  optional float width = 9;
  optional float height = 10;
  optional uint32 type = 11;
  optional float theta_to_adc =
      12;  // theta([-pi,pi)) of obstacle at adc_coordinate(right(x) front(y) up(z))
  optional bool is_interpolation_vec = 13;  // this frame is generated by interpolate
  optional float speed = 14;                // not dump
  optional float scalar_acc = 15;           // not dump
  optional Vec2d lf = 16;                   // left front point
  optional Vec2d rf = 17;                   // right front point
  optional Vec2d lr = 18;                   // not dump, left rear point
  optional Vec2d rr = 19;                   // not dump, right rear point
  optional int32 velocity_converged = 20;   // not dump
  optional int32 fusion_type = 21;
  optional double lane_feature_l = 22;  // lane_l of lane_feature
  optional bool is_smooth_position = 23;
  optional bool is_key_object = 24;
  optional int32 obs_state = 25;
}

message Segment {
  optional string segment_id = 1;
  repeated string predecessor = 2;
  repeated string successor = 3;
  repeated string left_neighbor = 4;
  repeated string right_neighbor = 5;
  optional int32 vector_start_idx = 6;
  optional int32 vector_end_idx = 7;
}

message LanePolyLine {
  optional string id = 1;
  repeated LaneVector lane_vector = 2;  // ~1.5m
  repeated Segment segment_info = 3;    // this polyline concat of many lanes
  repeated string successor = 4;        // polyline relation
  repeated string predecessor = 5;
  repeated string left_neighbor = 6;
  repeated string right_neighbor = 7;
  optional double total_length = 8;  // polyline length (sum of vectors) ~20m
}

message PolygonPolyLine {
  optional string id = 1;
  repeated PolygonVector polygon_vector = 2;
}

message StopLinePolyLine {
  optional string id = 1;
  repeated VecPoint stopline_vector = 2;
}

message LaneBoundaryPolyLine {
  optional string id = 1;
  repeated LaneBoundaryVector lane_boundary_vec = 2;
  repeated Segment segment_info = 3;  // this polyline concat of many lanes
}

message StaticMapPolyLine {
  repeated LanePolyLine lanes = 4;
  repeated LaneBoundaryPolyLine lane_boundarys = 5;
  optional bool is_update = 6;
  optional double timestamp = 7;
  repeated PolygonPolyLine polygons = 8;
  repeated StopLinePolyLine stoplines = 9;
}

message LaneFeature {
  optional string lane_id = 1;
  optional double s = 2;
  optional double l = 3;
  optional double angle_diff = 4;
  optional double lane_heading = 5;
  optional int32 nearby_type = 6;
  optional int32 lane_relation = 7;  // same with on line ObstacleLaneRelation
  optional int32 lane_type = 8;
}

message JunctionFeature {
  optional string id = 1;
  optional double entry_heading = 2;
  optional double distance = 3;
  optional LaneFeature entry_lane = 4;
  repeated LaneFeature exit_lane = 5;
  optional bool entry_heading_converged = 6;
  optional bool is_roundabout = 7;
}

message NearbyObstacle {
  optional string obs_id = 1;
  optional double s = 2;
  optional double l = 3;
}

message LaneSequence {
  optional int32 seq_id = 1;
  repeated string lane_ids = 2;
  repeated NearbyObstacle nearby_obstacle = 3;
  optional int32 action = 4;
  optional int32 turn_type = 5;
}

message LaneGraph {
  repeated LaneSequence lane_sequences = 1;
  repeated LaneSequence backward_lane_sequence = 2;
}

message Feature {
  optional string id = 1;
  optional int64 seq_num = 2;
  optional double timestamp = 3;
  optional Vec2d position = 4;
  optional double heading = 5;
  repeated PolylineInfo polyline_info = 6;
  repeated ObstacleVector obs_vec = 7;  // [..., curr_frame-2, curr_frame-1, curr_frame]
  optional LaneFeature lane_feature = 8;
  repeated LaneFeature current_lanes = 9;
  repeated LaneFeature nearby_lanes = 10;
  optional LaneGraph lane_graph = 11;
  optional LaneFeature left_front_lane_feature = 12;
  repeated LaneFeature left_front_lanes = 13;
  optional LaneFeature right_front_lane_feature = 14;
  repeated LaneFeature right_front_lanes = 15;
  repeated Tensor dump_tensors = 16;
  repeated JunctionFeature junction_feature = 17;
  repeated PredictionTrajectory prediction_trajectory = 18;
  optional int32 obs_static_scene = 19;
  repeated Vec2d corner_points = 20;
}

message PredictionTrajectory {
  optional double prob = 1;
  optional int32 intention = 2;
  optional int32 traj_type = 3;
  repeated PredictionPoint points = 4;
}

message PredictionPoint {
  optional Vec2d posiiton = 1;
  optional Vec2d velocity = 2;
  optional Vec2d acc = 3;
}

message Lane {
  optional string lane_id = 1;
  repeated Vec2d points = 2;
  repeated string successors = 3;
  repeated string predecessors = 4;
  repeated string lefts = 5;
  repeated string rights = 6;
  optional int32 lane_type = 7;

  optional string junction_id = 8;  // only add in junction lane
  optional double length = 9;
  optional double speed_limit = 10;
  optional int32 stop_line = 11;     // default lane end point
  optional int32 turn_type = 12;     // only add in junction lane
  optional int32 light_status = 13;  // only add in junction lane
                                     // 拓扑
  optional int32 split_topology = 14;
  optional int32 merge_topology = 15;
  // 左右车道边界
  repeated string left_lane_boundary_ids = 16;
  repeated string right_lane_boundary_ids = 17;
  //左右道路边界
  repeated string left_road_boundary_ids = 18;
  repeated string right_road_boundary_ids = 19;
  // 其他地图要素挂接 - id
  repeated string cross_walks = 20;
}

message Boundary {
  optional string boundary_id = 1;
  repeated Vec2d points = 2;
  optional int32 type = 3;
  optional int32 line_color = 4;  // when it is lane boundary
  optional double width = 5;      // when it is boundary
}

message Section {
  optional string id = 1;
  optional double length = 2;
  repeated string lane_ids = 3;
}

message NaviPosition {
  optional string section_id = 1;
  optional double s_offset = 2;
}

message NaviRoute {
  optional string id = 1;  //根据NavStatus状态，发送section id; 若导航终点不在覆盖范围内，则发空；
  optional NaviPosition navi_start = 2;  // 当前自车所在导航路径section id及偏移量；
  optional NaviPosition navi_end = 3;
  repeated Section sections = 4;
}

message Polygon {
  optional string id = 1;
  repeated Vec2d points = 2;
  optional int32 type = 3;
}

message LogicMap {
  optional double timestamp = 1;
  optional bool is_update = 2;
  repeated Lane lanes = 3;
  repeated Boundary boundaries = 4;
  optional NaviRoute navi_route = 5;
  repeated Polygon junctions = 6;
  repeated Polygon cross_walks = 7;
  repeated Boundary stopline = 8;
  repeated Boundary road_boundaries = 9;
}

message MapOffline {
  optional StaticMapPolyLine map_polyline = 1;
  optional LogicMap logic_map = 2;
}

message UnmovableObstacle {
  optional string id = 1;
  optional int64 seq_num = 2;
  optional double timestamp = 3;
  optional Vec2d position = 4;
  optional double heading = 5;
  optional double length = 6;
  optional double width = 7;
  optional double height = 8;
  // add polygon
  // add 自车方向盘
}

message OcculusionArea {
  optional string id = 1;
  optional PolygonPolyLine polyline = 2;
}

// Sample
message FrameFeature {
  optional int64 seq_num = 1;
  repeated Feature obstacle_features = 2;              // obstacle trajectory frame
  optional MapOffline map_offline = 3;                 // local map of adc (world coordinate)
  repeated UnmovableObstacle unmovable_obstacles = 4;  // unmovable_obstacles
  repeated OcculusionArea occulusion_areas = 5;        // occulusion areas
}

message Metadata {
  repeated string sample_name_list = 1;  // all the sample this databse contains
}
