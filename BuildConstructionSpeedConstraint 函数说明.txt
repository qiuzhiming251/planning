 BuildConstructionSpeedConstraint 函数说明，这是一个用于构建施工区域速度限制的函数。函数位于/decider/decision_manager/constraint_builder.cc

函数概述
这个函数为施工区域创建速度限制曲线，通过复杂的逻辑判断何时以及如何应用速度限制。

参数说明
- passage: 包含当前行驶路径信息
- psmm: 规划语义地图管理器，包含地图信息
- curent_set_speed: 车辆当前设定速度
- is_on_highway: 布尔值，表示车辆是否在高速公路上
- ego_v: 自车当前速度
- plan_start_time: 规划开始时间
- speed_state: 指向速度状态数据结构的指针
- override_passable: 驾驶员覆盖标志
- set_speed_sts: 设定速度状态标志
- traffic_flow_speed_min: 最小交通流速度
  
主要常量
函数定义了几个重要常量：
- 施工区域的速度阈值和限制
- 不同场景的距离阈值（汇合点、匝道等）
- 制动曲线的加速度值
- 各种条件的时间和距离参数
  
逻辑流程

1. 初始化设置
- 设置施工场景检测的布尔标志
- 定义速度限制和距离阈值
- 处理到子路径和匝道的距离信息
  
2. 场景检测
- 检查当前路径是否在施工场景中
- 验证车道序列信息是否存在
- 使用施工场景状态更新速度状态
  
3. 激活逻辑
- 为施工场景激活实现防抖机制
- 使用计数器和基于时间的逻辑跟踪激活状态
- 在退出激活施工区域后管理抑制周期
  
4. 距离计算
- 计算到汇合点的距离
- 跟踪在激活施工区域中的距离
- 管理接近和离开交叉口的状态
  
5. 退出条件
函数有多个早期退出条件，如果以下情况发生则返回错误：
- 接近汇合/分离交叉口（200米内）
- 离开汇合交叉口（300米内）
- 发生驾驶员干预（覆盖或设定速度）
- 不在施工场景中
- 在之前激活后的抑制范围内
- 不在高速公路上
- 在匝道区域（距离匝道500米内）
- 超出施工区域范围（1.5公里）
- 速度低于有效范围
  
6. 速度曲线计算
- 基于当前设置和交通流确定目标速度
- 根据速度范围应用不同的减速系数：
  - 100公里/小时以下使用较慢减速（90%）
  - 更高速度使用较快减速（80%）
- 在规划时间范围内创建分段线性速度曲线
- 实现-1.5米/秒²加速度的制动曲线
  
7. 输出
- 返回包含计算速度曲线的 ConstraintProto::SpeedProfileProto
- 将约束源设置为施工场景
  



详细解释

施工预备减速主要分为两部分逻辑，详细解释部分分两部分解释，ODD逻辑和速度规划部分。

功能ODD逻辑

1. 状态初始化
is_construction_speed_constrain_working =
    is_construction_scene && speed_state->is_construction_scene_speed_plan;
- 当前施工速度限制功能是否工作 = 检测到施工场景 AND 速度规划中启用了施工场景标志
- 这是功能激活的基本条件
  
2. 状态比较与变化检测
is_construction_speed_constrain_working_pre =
    speed_state->is_construction_speed_constrain_working_pre;
- 保存上一次的施工速度限制工作状态
- 用于检测状态变化（进入/退出）
  
3. 防抖机制 - 状态变化标志设置
// active debounce time count flag
if (!is_construction_speed_constrain_working &&
    is_construction_speed_constrain_working_pre) {
  // 从激活状态变为非激活状态
  speed_state->is_active_count = false;
} else if (is_construction_speed_constrain_working &&
           !is_construction_speed_constrain_working_pre) {
  // 从非激活状态变为激活状态
  speed_state->is_active_count = true;
}
- 退出检测: 如果当前未激活但之前激活，设置计数标志为false
- 进入检测: 如果当前激活但之前未激活，设置计数标志为true
- 这个防抖机制防止状态快速切换
  
4. 激活计数器逻辑
// acitve debounce time counter
if (speed_state->is_active_count) {
  int function_active_count = speed_state->function_active_count;
  function_active_count = std::clamp(function_active_count + 1, 0, 5);
  speed_state->function_active_count = function_active_count;
  if (speed_state->function_active_count > 3) {
    speed_state->is_active_flag = true;
  }
}
- 当进入标志被设置时，开始计数
- 计数器在0-5之间限制
- 每次执行函数时计数+1
- 当计数超过3时，设置 is_active_flag = true，正式激活功能
- 这确保功能不会因为短暂的检测而激活
  
5. 退出时的重置逻辑
// reset flag when exit.
if (!is_construction_speed_constrain_working &&
    is_construction_speed_constrain_working_pre) {
  speed_state->function_active_count = 0;
  // Suppress re-activation for a distance after activation.
  if (speed_state->dist_construction_active > 0.0 &&
      speed_state->dist_construction_active < kDistConstructionActiveRng) {
    speed_state->is_exit_among_active_inhibit_rng =
        true;  // Exit in Active inhibit Interval
  }
}
- 检测到功能退出时（当前未激活但之前激活）
- 重置激活计数器为0
- 重要逻辑: 如果在激活距离范围内退出（0 < dist_construction_active < 3000m），设置抑制标志
- 这防止在施工区域附近频繁进入退出
  
6. 抑制标志管理
// reset inhibit flag when dist_construction_active large than
// kDistConstructionActiveRng
if (speed_state->dist_construction_active >= kDistConstructionActiveRng) {
  speed_state->is_exit_among_active_inhibit_rng = false;
  speed_state->is_active_flag = false;
  speed_state->dist_construction_active = 0.0;
}
- 当激活距离超过阈值（3000米）时
- 重置抑制标志，允许重新激活
- 重置激活标志
- 重置激活距离计数
7. 退出和抑制激活条件
施工区域速度限制功能的退出和抑制激活条件
  
退出条件（Early Return Conditions）
  
  函数中有多个退出条件，当满足以下任一条件时，函数返回错误并退出：
  
  1. 接近汇合/分离交叉口
    - 条件：abs(dist_to_subpath) <= kDistConstructionNearSubpath (200米)
    - 含义：车辆距离汇合或分离点200米以内
      
  2. 离开汇合点后距离不足
    - 条件：speed_state->dist_away_merge_point <= kDistConstructionDepartSubpath (300米)
    - 含义：车辆离开汇合点的距离不超过300米
      
  3. 驾驶员干预
    - 条件：(override_passable || set_speed_sts) && is_construction_speed_constrain_working
    - 含义：驾驶员覆盖或设定速度，且功能正在工作
      
  4. 非施工场景
    - 条件：!is_construction_scene
    - 含义：当前不在施工场景中
      
  5. 抑制范围内
    - 条件：is_construction_scene && speed_state->is_exit_among_active_inhibit_rng
    - 含义：在施工场景中，但处于抑制范围内
      
  6. 非高速公路
    - 条件：!is_on_highway
    - 含义：当前不在高速公路上
      
  7. 匝道区域
    - 条件：dist_to_ramp >= 0 && dist_to_ramp <= kDistConstructionNearRamp (500米)
    - 含义：车辆在匝道区域（距离匝道500米内）
      
  8. 超出施工区域范围
    - 条件：speed_state->dist_construction_active > kDistConstructionExitRng (1500米)
    - 含义：在施工区域中行驶距离超过1500米
      
  9. 速度过低
    - 条件：curent_set_speed < kConstructionSpeedLimitMinSpeed 或 curent_set_speed == kConstructionSpeedLimitNull 或 ego_v < kConstructionSpeedLimitMinSpeed
    - 含义：当前设定速度或实际速度低于最小有效速度（约60km/h）
      
速度规划部分
  速度曲线计算的逻辑部分：
// calculate brake to target speed
double target_set_speed = 0.0;
if (abs(speed_state->pre_cruising_speed_limit - curent_set_speed) >
    kMathEpsilon) {
  target_set_speed = std::clamp(
      std::min(speed_state->pre_cruising_speed_limit, curent_set_speed),
      kConstructionSpeedLimitMinSpeed, kConstructionSpeedLimitMaxSpeed);
} else {
  target_set_speed = curent_set_speed;
}
目标速度计算逻辑

1. 目标速度确定
- 首先比较之前的速度限制 pre_cruising_speed_limit 和当前设定速度 curent_set_speed
- 如果两者差异大于 kMathEpsilon（数学精度阈值），说明速度设置发生了变化
- 在这种情况下，选择两个速度中的较小值作为目标速度
- 然后将目标速度限制在最小速度（约60km/h）和最大速度（130km/h）之间
- 如果两者差异很小（在精度范围内），则直接使用当前设定速度
  
2. 速度范围分类处理
double min_acc_csl = 0.0;
double target_speed_csl = 0.0;

if (target_set_speed >= kConstructionSpeedLimitMinSpeed &&
    target_set_speed <= kConstructionSpeedLimitMidSpeed) {
  target_speed_csl =
      std::max(kConstructionSpeedLimitMinSpeed,
               std::min(target_set_speed * kEgoDecSlowGain, flow_speed_min));
}

if (target_set_speed > kConstructionSpeedLimitMidSpeed &&
    target_set_speed <= kConstructionSpeedLimitMaxSpeed) {
  target_speed_csl =
      std::max(kConstructionSpeedLimitMinTargetSpeed,
               std::min(target_set_speed * kEgoDecFastGain, flow_speed_min));
}
min_acc_csl = kConstructionPreBrakeAcc;

根据目标速度的大小，采用不同的处理策略：

低速范围（60km/h - 100km/h）：
- 使用较慢的减速系数 kEgoDecSlowGain = 0.9
- 目标速度 = min(当前目标速度 × 0.9, 最小交通流速度)
- 确保不低于最小速度限制
  
高速范围（100km/h - 130km/h）：
- 使用较快的减速系数 kEgoDecFastGain = 0.8
- 目标速度 = min(当前目标速度 × 0.8, 最小交通流速度)
- 确保不低于最小目标速度（约90km/h）
  
3. 速度曲线生成
const double speed_profile_time_range =
    kTrajectoryTimeStep * kTrajectorySteps;
PiecewiseLinearFunctionDoubleProto construction_scene_speed_profile;
construction_scene_speed_profile.mutable_x()->Reserve(m);
construction_scene_speed_profile.mutable_y()->Reserve(m);
for (double t = 0.0; t <= speed_profile_time_range;
     t += kSampleStepNum * kTrajectoryTimeStep) {
  construction_scene_speed_profile.add_x(t);
  construction_scene_speed_profile.add_y(
      std::max(ego_v + min_acc_csl * t, target_speed_csl));
}

时间范围计算：
- speed_profile_time_range = 轨迹时间步长 × 轨迹步数
- 这定义了速度曲线的总时间长度
  
曲线生成逻辑：
- 从时间 t=0 开始，以 kSampleStepNum * kTrajectoryTimeStep 为间隔采样
- 对于每个时间点 t，计算对应的速度值
- 速度值计算公式：max(ego_v + min_acc_csl * t, target_speed_csl)
  - ego_v：车辆当前速度
  - min_acc_csl：制动加速度（-1.5 m/s²）
  - target_speed_csl：计算出的目标速度下限
    
速度曲线特点：
- 初始状态：从当前车速 ego_v 开始
- 减速过程：以 -1.5 m/s² 的加速度线性减速
- 下限保护：速度不会低于计算出的目标速度 target_speed_csl
- 时间覆盖：覆盖整个规划时间范围
  
